"""
Contribution tracking system for agents and tools.
Logs what each agent and tool contributed to the report generation process.
"""

import json
import logging
import re
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, asdict
from config import settings

logger = logging.getLogger(__name__)


@dataclass
class ToolContribution:
    """Records a tool's contribution to the research."""
    tool_name: str
    tool_type: str  # 'web_scraper', 'api_caller', 'llm', 'visualization'
    invocation_count: int
    data_collected: str  # Summary of data collected
    execution_time: float  # seconds
    success: bool
    output_files: List[str]  # Files generated by this tool
    metadata: Dict[str, Any]


@dataclass
class AgentContribution:
    """Records an agent's contribution to the report."""
    agent_name: str
    agent_type: str  # 'lead_researcher', 'data_collector', 'api_researcher', 'analyst', 'writer', 'cost_calculator'
    start_time: str
    end_time: str
    duration: float  # seconds
    status: str  # 'completed', 'failed', 'partial'
    
    # What the agent did
    task_description: str
    actions_taken: List[str]
    
    # What the agent produced
    output_summary: str
    output_files: List[str]
    
    # Tools used by this agent
    tools_used: List[ToolContribution]
    
    # Token usage
    tokens_used: int
    estimated_cost: float
    
    # Agent-specific metrics
    metrics: Dict[str, Any]
    
    # Errors if any
    errors: List[str]


class ContributionTracker:
    """
    Tracks and logs contributions from agents and tools during report generation.
    Saves detailed logs to data/agent-contribution/ directory.
    """
    
    def __init__(self, session_id: str, topic: str):
        """
        Initialize contribution tracker for a report session.
        
        Args:
            session_id: Unique session identifier
            topic: Research topic
        """
        self.session_id = session_id
        self.topic = topic
        self.start_time = datetime.now()
        
        # Contributions storage
        self.agent_contributions: List[AgentContribution] = []
        self.tool_contributions: List[ToolContribution] = []
        
        # Setup output directory
        self.output_dir = Path(settings.reports_dir).parent / "agent-contribution" / session_id
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        logger.info(f"Contribution tracker initialized for session: {session_id}")
    
    def log_agent_start(self, agent_name: str, agent_type: str, task: str) -> Dict[str, Any]:
        """
        Log when an agent starts execution.
        
        Args:
            agent_name: Name of the agent
            agent_type: Type/role of the agent
            task: Description of the task
            
        Returns:
            Context dictionary to pass to log_agent_end
        """
        context = {
            "agent_name": agent_name,
            "agent_type": agent_type,
            "task": task,
            "start_time": datetime.now().isoformat(),
            "start_timestamp": datetime.now().timestamp()
        }
        
        logger.info(f"Agent started: {agent_name} ({agent_type}) - {task}")
        return context
    
    def log_agent_end(
        self,
        context: Dict[str, Any],
        status: str,
        output_summary: str,
        output_files: List[str] = None,
        tools_used: List[ToolContribution] = None,
        tokens_used: int = 0,
        estimated_cost: float = 0.0,
        metrics: Dict[str, Any] = None,
        actions_taken: List[str] = None,
        errors: List[str] = None
    ):
        """
        Log when an agent completes execution.
        
        Args:
            context: Context from log_agent_start
            status: Completion status
            output_summary: Summary of what the agent produced
            output_files: List of files generated
            tools_used: List of tools the agent used
            tokens_used: Number of tokens consumed
            estimated_cost: Cost in USD
            metrics: Agent-specific metrics
            actions_taken: List of actions the agent performed
            errors: List of errors encountered
        """
        end_time = datetime.now()
        duration = end_time.timestamp() - context["start_timestamp"]
        
        contribution = AgentContribution(
            agent_name=context["agent_name"],
            agent_type=context["agent_type"],
            start_time=context["start_time"],
            end_time=end_time.isoformat(),
            duration=duration,
            status=status,
            task_description=context["task"],
            actions_taken=actions_taken or [],
            output_summary=output_summary,
            output_files=output_files or [],
            tools_used=tools_used or [],
            tokens_used=tokens_used,
            estimated_cost=estimated_cost,
            metrics=metrics or {},
            errors=errors or []
        )
        
        self.agent_contributions.append(contribution)
        
        # Save individual agent contribution file
        self._save_agent_contribution(contribution)
        
        logger.info(f"Agent completed: {context['agent_name']} - Duration: {duration:.2f}s, Status: {status}")
    
    def log_tool_usage(
        self,
        tool_name: str,
        tool_type: str,
        data_collected: str,
        execution_time: float,
        success: bool = True,
        output_files: List[str] = None,
        metadata: Dict[str, Any] = None
    ) -> ToolContribution:
        """
        Log tool usage and contribution.
        
        Args:
            tool_name: Name of the tool
            tool_type: Type of tool
            data_collected: Summary of data collected
            execution_time: Execution time in seconds
            success: Whether the tool succeeded
            output_files: Files generated by the tool
            metadata: Additional metadata
            
        Returns:
            ToolContribution object
        """
        # Check if tool already logged, increment count
        existing = next(
            (t for t in self.tool_contributions if t.tool_name == tool_name),
            None
        )
        
        if existing:
            existing.invocation_count += 1
            existing.execution_time += execution_time
            existing.output_files.extend(output_files or [])
            tool_contrib = existing
        else:
            tool_contrib = ToolContribution(
                tool_name=tool_name,
                tool_type=tool_type,
                invocation_count=1,
                data_collected=data_collected,
                execution_time=execution_time,
                success=success,
                output_files=output_files or [],
                metadata=metadata or {}
            )
            self.tool_contributions.append(tool_contrib)
        
        logger.debug(f"Tool used: {tool_name} ({tool_type}) - {execution_time:.2f}s")
        return tool_contrib
    
    def _sanitize_topic_for_filename(self, topic: str, max_length: int = 50) -> str:
        """
        Sanitize topic string for use in filename.
        
        Args:
            topic: Research topic string
            max_length: Maximum length for filename-safe topic
            
        Returns:
            Sanitized topic string safe for filenames
        """
        # Replace spaces and special characters with underscores
        sanitized = re.sub(r'[^\w\s-]', '', topic)  # Remove special chars except word chars, spaces, hyphens
        sanitized = re.sub(r'[-\s]+', '_', sanitized)  # Replace spaces and hyphens with underscores
        sanitized = sanitized.strip('_')  # Remove leading/trailing underscores
        
        # Limit length
        if len(sanitized) > max_length:
            sanitized = sanitized[:max_length].rstrip('_')
        
        # Ensure it's not empty
        if not sanitized:
            sanitized = "untitled"
        
        return sanitized.lower()
    
    def _save_agent_contribution(self, contribution: AgentContribution):
        """Save individual agent contribution to file."""
        # Format: agent_name_YYYYMMDD_HHMMSS_topic.json
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        sanitized_topic = self._sanitize_topic_for_filename(self.topic)
        filename = f"{contribution.agent_name}_{timestamp}_{sanitized_topic}.json"
        filepath = self.output_dir / filename
        
        with open(filepath, 'w') as f:
            json.dump(asdict(contribution), f, indent=2, default=str)
        
        logger.debug(f"Saved agent contribution: {filepath}")
    
    def generate_summary_report(self) -> Dict[str, Any]:
        """
        Generate a comprehensive summary of all contributions.
        
        Returns:
            Summary dictionary
        """
        end_time = datetime.now()
        total_duration = (end_time - self.start_time).total_seconds()
        
        summary = {
            "session_id": self.session_id,
            "topic": self.topic,
            "start_time": self.start_time.isoformat(),
            "end_time": end_time.isoformat(),
            "total_duration": total_duration,
            
            "agents": {
                "total_agents": len(self.agent_contributions),
                "successful": len([a for a in self.agent_contributions if a.status == "completed"]),
                "failed": len([a for a in self.agent_contributions if a.status == "failed"]),
                "contributions": [
                    {
                        "agent": a.agent_name,
                        "type": a.agent_type,
                        "duration": a.duration,
                        "status": a.status,
                        "output": a.output_summary,
                        "files_generated": len(a.output_files),
                        "tools_used": len(a.tools_used),
                        "tokens": a.tokens_used,
                        "cost": a.estimated_cost
                    }
                    for a in self.agent_contributions
                ]
            },
            
            "tools": {
                "total_tools": len(self.tool_contributions),
                "total_invocations": sum(t.invocation_count for t in self.tool_contributions),
                "total_execution_time": sum(t.execution_time for t in self.tool_contributions),
                "contributions": [
                    {
                        "tool": t.tool_name,
                        "type": t.tool_type,
                        "invocations": t.invocation_count,
                        "execution_time": t.execution_time,
                        "success": t.success,
                        "data_collected": t.data_collected,
                        "files_generated": len(t.output_files)
                    }
                    for t in self.tool_contributions
                ]
            },
            
            "totals": {
                "total_tokens": sum(a.tokens_used for a in self.agent_contributions),
                "total_cost": sum(a.estimated_cost for a in self.agent_contributions),
                "total_files_generated": sum(len(a.output_files) for a in self.agent_contributions),
                "total_errors": sum(len(a.errors) for a in self.agent_contributions)
            }
        }
        
        return summary
    
    def save_summary(self):
        """Save comprehensive summary report."""
        summary = self.generate_summary_report()
        
        # Save JSON summary
        summary_file = self.output_dir / "SUMMARY.json"
        with open(summary_file, 'w') as f:
            json.dump(summary, f, indent=2, default=str)
        
        # Save human-readable markdown summary
        markdown_file = self.output_dir / "SUMMARY.md"
        self._save_markdown_summary(summary, markdown_file)
        
        logger.info(f"Summary report saved: {summary_file}")
        return summary_file
    
    def _save_markdown_summary(self, summary: Dict[str, Any], filepath: Path):
        """Generate and save markdown-formatted summary."""
        lines = [
            f"# Agent Contribution Report",
            f"",
            f"**Session ID:** `{summary['session_id']}`  ",
            f"**Topic:** {summary['topic']}  ",
            f"**Duration:** {summary['total_duration']:.2f} seconds  ",
            f"**Generated:** {summary['end_time']}  ",
            f"",
            f"---",
            f"",
            f"## ðŸ“Š Overview",
            f"",
            f"- **Total Agents:** {summary['agents']['total_agents']}",
            f"- **Successful:** {summary['agents']['successful']}",
            f"- **Failed:** {summary['agents']['failed']}",
            f"- **Total Tools Used:** {summary['tools']['total_tools']}",
            f"- **Tool Invocations:** {summary['tools']['total_invocations']}",
            f"- **Total Tokens:** {summary['totals']['total_tokens']:,}",
            f"- **Total Cost:** ${summary['totals']['total_cost']:.4f}",
            f"",
            f"---",
            f"",
            f"## ðŸ¤– Agent Contributions",
            f""
        ]
        
        for contrib in summary['agents']['contributions']:
            lines.extend([
                f"",
                f"### {contrib['agent']} ({contrib['type']})",
                f"",
                f"- **Status:** {contrib['status']}",
                f"- **Duration:** {contrib['duration']:.2f}s",
                f"- **Output:** {contrib['output']}",
                f"- **Files Generated:** {contrib['files_generated']}",
                f"- **Tools Used:** {contrib['tools_used']}",
                f"- **Tokens:** {contrib['tokens']:,}",
                f"- **Cost:** ${contrib['cost']:.4f}",
                f""
            ])
        
        lines.extend([
            f"",
            f"---",
            f"",
            f"## ðŸ”§ Tool Contributions",
            f""
        ])
        
        for tool in summary['tools']['contributions']:
            lines.extend([
                f"",
                f"### {tool['tool']} ({tool['type']})",
                f"",
                f"- **Invocations:** {tool['invocations']}",
                f"- **Total Execution Time:** {tool['execution_time']:.2f}s",
                f"- **Success:** {'âœ…' if tool['success'] else 'âŒ'}",
                f"- **Data Collected:** {tool['data_collected']}",
                f"- **Files Generated:** {tool['files_generated']}",
                f""
            ])
        
        with open(filepath, 'w') as f:
            f.write('\n'.join(lines))


# Tracker registry to store trackers outside of LangGraph state
# (LangGraph state must be serializable, but ContributionTracker is not)
_tracker_registry: Dict[str, ContributionTracker] = {}


def create_contribution_tracker(session_id: str, topic: str) -> ContributionTracker:
    """
    Factory function to create a contribution tracker.
    Stores tracker in registry for retrieval by session_id.
    
    Args:
        session_id: Session identifier
        topic: Research topic
        
    Returns:
        ContributionTracker instance
    """
    tracker = ContributionTracker(session_id, topic)
    _tracker_registry[session_id] = tracker
    logger.info(f"Created and registered tracker for session: {session_id}")
    return tracker


def get_contribution_tracker(session_id: str) -> Optional[ContributionTracker]:
    """
    Get contribution tracker by session ID.
    
    Args:
        session_id: Session identifier
        
    Returns:
        ContributionTracker instance or None if not found
    """
    return _tracker_registry.get(session_id)


def remove_contribution_tracker(session_id: str):
    """
    Remove tracker from registry (cleanup after session complete).
    
    Args:
        session_id: Session identifier
    """
    if session_id in _tracker_registry:
        del _tracker_registry[session_id]
        logger.debug(f"Removed tracker for session: {session_id}")

